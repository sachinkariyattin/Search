"""
The algorithm returns an optimal solution for N <= 24, where N is the total number of people. For N > 24, the computation takes a lot of time, hence a sub optimal solution is returned for N > 24.

The implementation steps are given below (N <= 24):

1. A map(dictionary) is created based on the given input in the following format
    {<person> : <friends>}
2. The list of keys in the dictionary is sorted based on the maximum number of friends known.
3. The first person in the list(who knows the max number of people) is placed on the first table and then the successors are generated by placing one person at a time.
4. When all the people in the list are assigned to tables, count the number of tables K and store the arrangement in a list.
5. While generating the successors, check if the number of tables is greater than or equal to count K (current optimal solution). If it is greater than or equal to,
    then that successor can be pruned.
6. Finally check the final arrangements list and display the arrangement with the least number of tables.


For N > 24

1. A map(dictionary) is created based on the given input in the following format
    {<person> : <friends>}
2. The list of keys in the dictionary is sorted based on the maximum number of friends known.
3. group_tables() function is used to assign a person to each table based on whether the person knows the other people sitting in current table.
"""

import sys
import copy

class Table(object):
    def __init__(self):
        self.people_in_table = []
        self.all_friends = set()

    def add_person(self,entry,map):
        self.people_in_table.append(entry)
        self.all_friends.update(map[entry])

# Read the contents of the file
def read_file(filename):
    lines = [line.rstrip('\n') for line in open(filename)]
    split_lines = []
    for i in lines:
        split_item = i.split()
        split_lines.append(split_item)
    return split_lines

# Create a map of people who know each other from the extracted file
def create_map(extracted_lines):
    friends_map = {}
    for people in extracted_lines:
        friends_map.setdefault(people[0],[])
        for j in people[1:]:
            friends_map[people[0]].append(j)
            friends_map.setdefault(j,[])
            friends_map[j].append(people[0])
    return  friends_map

# Sort the list based on the highest number of friends per person
def sort_based_friends(friends_map):
    sort_list = []
    for v in friends_map:
        if not sort_list:
            sort_list.append(v)
        else:
            if len(friends_map[v]) < len(sort_list[0]):
                sort_list.append(v)
            else:
                sort_list.insert(0,v)
    return sort_list

# count the number of people per table
def count_people(table_list):
    total_people = 0
    for k in table_list:
        total_people += len(k.people_in_table)
    return total_people

# Generate successors per each table
def table_successor(current_tables,friends_map,sorted_list,max_no):
    index_of_last_person = count_people(current_tables)
    current_person = sorted_list[index_of_last_person]
    successors_list = []

    copy_current_table = copy.deepcopy(current_tables)

    put_person = Table()
    put_person.add_person(current_person, friends_map)
    copy_current_table.append(put_person)
    if not len(copy_current_table) >= set_initial_tables_prune:
        successors_list.append(copy_current_table)

    for o in current_tables:
        if not current_person in o.all_friends and len(o.people_in_table) < max_no:
            copy_table = copy.deepcopy(current_tables)
            get_index = current_tables.index(o)
            place_person = copy_table[get_index]
            place_person.add_person(current_person,friends_map)
            if not len(copy_table) >= set_initial_tables_prune:
                successors_list.append(copy_table)

    return  successors_list


# Start with initial state by placing the person who knows the highest number of people
def solve(friends_map,sorted_list,max_no):
    final_arrangement = []
    tables = []
    put_person = Table()
    initial_key = sorted_list[0]
    put_person.add_person(initial_key, map)
    tables.append(put_person)
    fringe = [tables]
    global set_initial_tables_prune
    set_initial_tables_prune = len(sorted_list) + 1 #initialize with some large value

    while len(fringe) > 0:
        pop_fringe = fringe.pop()
        for s in table_successor(pop_fringe,friends_map,sorted_list,max_no):
            if(count_people(s) == len(sorted_list)):
                if(len(s) < set_initial_tables_prune):
                    set_initial_tables_prune = len(s)
                final_arrangement.append(s)
            else:
                fringe.append(s)
    return final_arrangement


# Sub optimal solution if no of people are more than 24
def group_tables(sorted_list,map,max_no):
    tables = []
    for key in sorted_list:
        if len(tables) > 0:
            k = 0
            for o in tables:
                if not key in o.all_friends and len(o.people_in_table) < max_no:
                    o.add_person(key,map)
                    k = 1
                    break
            if k == 0:
                put_person = Table()
                put_person.add_person(key, map)
                tables.append(put_person)
        else:
            put_person = Table()
            put_person.add_person(key, map)
            tables.append(put_person)
    return  tables


# Calculate the minimum number of tables
def compute_min_ele(final_arrangement):
    size_list = []
    for j in final_arrangement:
        size_list.append(len(j))

    min_no_table = min(size_list)
    min_table_index = size_list.index(min_no_table)

    return final_arrangement[min_table_index]


# Display final result
def disp_pattern(total_tables):
    final_string = ""
    for k in total_tables:
        final_string += ",".join(k.people_in_table)
        final_string += "  "
    return final_string


if len(sys.argv) < 3:
    print "Please enter the missing parameter: No of tables"
    sys.exit()

extracted_lines = read_file(sys.argv[1])
map = create_map(extracted_lines)
sorted_list = sort_based_friends(map)

if len(sorted_list) > 24:
    final_result = group_tables(sorted_list,map,int(sys.argv[2]))
else:
    final_arrangement = solve(map,sorted_list,int(sys.argv[2]))
    final_result = compute_min_ele(final_arrangement)

print str(len(final_result)) + " " +disp_pattern(final_result)

